协程

协程是在编译器层面用软件的方式实现的，线程是硬件中断实现的，所以协程的切换不会引起线程的切换，线程的切换有它自己的机制，
跟协程无关，但是协程是站在线程的基础上实现运作的，没有线程就不可能实现协程。从实现的效果来看，两者是类似的，
都是程序在运行一段时间后保存现场然后跳转执行另一段程序，区别在于程序员可以在协程指定何处进行跳转以及经历多长时间再跳转回来，
相当于指定了协程的切换时间。而线程切换的时间一般是在操作系统内核时钟中断函数中指定的，程序员无法修改。

协程是自己程序调度的，逻辑上并行执行，底层上非并行执行
线程是操作系统调度的，逻辑和底层上都是并行执行

coroutine是可以在任意行中断然后继续的函数， 一般的函数routine只是coroutine的一种特殊情况

线程是操作系统级别的概念，现代操作系统都实现并且支持线程，线程的调度对应用开发者是透明的，开发者无法预期某线程在何时被调度执行。
基于此，一般那种随机出现的BUG，多与线程调度相关。
coroutine则是一个概念，windows上有所谓的fiber纤程实现，而好些语言中也自带coroutine的实现，比如Lua。
与线程最大的不同是，coroutine的调度/挂起/执行开发者是可以控制的。另外coroutine也比线程轻量的多。
要在语言层面实现coroutine，需要内部有一个类似栈的数据结构，当该coroutine被挂起时要保存该coroutine的数据现场以便恢复执行。
所以要比线程更加轻量级。
coroutine你可以将它看成一个用户态的线程（一般来它也提供了入口函数、调用的参数，以及你放置局部变量的栈）
，只不过它是你自己调度的，而且不同coroutine的切换不需要陷入内核态，效率比较高。
linux有提供了getcontext swapcontext等接口来实现coroutine，windows貌似也有相关的。
一般来说coroutine用在异步的场景比较好，异步执行一般需要维护一个状态机，状态的维护需要保存在全局里或者你传进来的参数来，
因为每一个状态回调都会重新被调用。有了coroutine(stackfull)的话你可以不用担心这个问题，你可以像写同步的代码那样子，
但其实底层还是异步的，只不过你在等待数据时执行的上下文会暂时被保存起来，等到数据来临再将上下文恢复继续执行。
还有一种coroutine是stackless，它本质上也是状态机实现的，并不能在它上面让不同的状态共享局部变量，貌似boost.asio.coroutine就是这种

线程是内核对外提供的服务，应用程序可以通过系统调用让内核启动线程，由内核来负责线程调度和切换。
线程在等待IO操作时线程变为unrunnable状态会触发上下文切换。现代操作系统一般都采用抢占式调度，
上下文切换一般发生在时钟中断和系统调用返回前，调度器计算当前线程的时间片，如果需要切换就从运行队列中选出一个目标线程，
保存当前线程的环境，并且恢复目标线程的运行环境，最典型的就是切换ESP指向目标线程内核堆栈，将EIP指向目标线程上次被调度出时的指令地址。
协程也叫用户态线程，协程之间的切换发生在用户态。在用户态没有时钟中断，系统调用等机制，
那么协程切换由什么触发？调度器将控制权交给某个协程后，控制权什么时候回到调度器，从而调度另外一个协程运行？
实际上，这需要协程主动放弃CPU，控制权回到调度器，从而调度另外一个协程运行。所谓协作式线程(cooperative)，
需要协程之间互相协作，不需要使用CPU时将CPU主动让出。
协程切换和内核线程的上下文切换相同，也需要有机制来保存当前上下文，恢复目标上下文。
在POSIX系统上，getcontext/makecontext/swapcontext等可以用来做这件事。
协程带来的最大的好处就是可以用同步的方式来写异步的程序。
比如协程A，B：A是工作协程，B是网络IO协程(这种模型下，实际工作协程会比网络IO协程多)，
A发送一个包时只需要将包push到A和B之间的一个channel，然后就可以主动放弃CPU，
让出CPU给其它协程运行，B从channel中pop出将要发送的包，接收到包响应后，将结果放到A能拿到的地方，
然后将A标识为ready状态，放入可运行队列等待调度，A下次被调度器调度就可以拿到结果继续做后面的事情。
如果是基于线程的模型，A和B都是线程，通常基于回调的方式，1. A阻塞在某个队列Q上，
B接受到响应包回调A传给B的回调函数f，回调函数f将响应包push到Q中，A可以取到响应包继续干活，
如果阻塞基于cond等机制，则会被OS调度出去，如果忙等，则耗费CPU。2. A可以不阻塞在Q上，而是继续做别的事情，
可以定期过来取结果。 这种情况下，线程模型业务逻辑其实被打乱了，发包和取包响应的过程被隔离开了。
实现协程库的基本思路很简单，每个线程一个调度器，就是一个循环，不断的从可运行队列中取出协程，
并且利用swapcontext恢复协程的上下文从而继续执行协程。当一个协程放弃CPU时，
通过swapcontext恢复调度器上下文从而将控制权归还给调度器，调度器从可运行队列选择下一个协程。
每个协程初始化通过getcontext和makecontext，需要的栈空间从堆上分配即可。
