处理器之间的松耦合与紧耦合问题。
解决共享虚拟内存的两类算法：集中式和分布式
将虚拟内存应用到共享内存的并行机中。
共享虚拟内存提供一个虚拟地址空间，可以在一个松耦合分布式内存的多处理器系统中所有的处理器之间共享。
共享虚拟内存不仅在物理内存和硬盘之间对数据进行分页，而且还在独立处理器的物理内存之间进行分页。
因此，数据可以自然的按需求在不同处理器之间进行迁移。
共享虚拟内存的问题是解决内存一致性问题，类似于在共享内存多处理器的多缓存机制中遇到的完呢提。
内存映射管理器，地址映射，地址一致性，就是说读操作返回的值和最近写到同一地址的值是一样的。
共享地址空间是以页划分的，标记为只读的页可以存在许多许多处理器的物理内存中，而标记为可写的页在某一时刻只能在一个处理器的内存中。
内存映射管理器把本地内存看作是共享虚拟内存的一大块cache。
当引用的内存不在当前机器的物理内存中时，内存映射管理器就会去远端取回这块内存，如果当前引用的内存在其他机器上也有副本，
那么他会采取一些措施来维护内存一致性。
我们的并行程序模型是一个进程或线程的集合，并且他们是轻量级的，也就是说进程的上下文切换，进程的创建，终止都是开销很低的。
共享虚拟内存的关键目标之一就是允许程序过程在不同的处理器上并行的执行。因此，内存映射管理器也要集成进程管理器和内存分配管理器的功能。
共享虚拟内存上并行程序的性能主要取决于两个因素：进程数量，共享数据的更新度。
更新共享数据未必会引起thrashing，如果一个程序表现出很好的局部性。
在传统虚拟内存中，顺序程序中的内存引用具有很好的局部性。并行程序中单个进程仍然是一个顺序程序，它也应该表现出很好的局部性。
影响共享虚拟内存的两个设计选择是：内存单元的粒度，维持一致性的策略。
粒度：发送1000字节和10自己的代价可能相差不大，因为操作系统的软件协议和虚拟内存层带来的中间耗费。
如果中间耗费可以接受，那么在虚拟内存中内存单元就可以相对大一些。但是另一方面，内存单元越大，内存竞争的几率也越大。
特定实现的详细细节也许允许客户端(使用接口的人)编程人员安排对不同内存单元中的内存地址并发内存访问来最小化竞争。
要么是客户端要么是共享虚拟内存存储分配器会使用这种访问策略，但是这也许会导致不能高效使用内存。因此，竞争的可能性暗示需要相对小的内存单元。
页大小的尺寸选择和传统虚拟内存页大小一致可以利用现有的页错误机制。
尤其是可以利用MMU中的保护机制，它允许单指令触发页错误并且陷入合适的错误处理中。(???)
程序可以以这样一种方式来设置对页的访问权限：会破坏内存一致性的内存访问将引起一个页错误；内存一致性问题就可以在页错误处理者和错误服务者中以组合的方式
来就解决。

内存一致性策略：
    解决方法可以分为：页同步和页持有权两类
        页同步：
              两个基本解法解决页同步问题：页失效和写广播
                    在页失效策略中：每一个页只有一个主处理器(享有持有权).它可以读也可以写。
                                   如果处理器Q对页P有写错误，那么错误处理就
                                          ---把所有P的副本都失效
                                          ---把对P的权限改为写
                                          ---如果Q没有P的副本就取一个副本
                                          ---返回到引起错误的指令中
                                   返回后，处理器Q就成为了P的主处理器，它可以继续写操作和其他的读写操作，直到页的持有权限被让给其他处理器。
                                   如果处理器Q对页P有一个读错误，那么错误处理就
                                          ---把对P有写权限的处理器改成读
                                          ---取一个P的副本到Q上并且把P的权限设为读
                                          ---返回到引起错误的指令上
                     在写广播策略中：处理器处理读错误的方式和页失效中一样，
                                    如果处理器有写错误，那么错误处理就
                                          ---对所有该页的副本执行写操作
                                          ---返回到引起错误的指令上
                                    这种方式的主要问题是他需要特殊的硬件支持：每次对共享页的写操作都需要在写处理器上产生一个错误，并且更新所有的副本
                                    因为共享虚拟内存的哲学就是要求所有的页是自由的共享。为了防止处理器在返回到引发错误指令上时在此有同样的页错误，
                                    硬件必须能够跳过这个故障写周期。
         页持有权：
                 页的持有权可以是固定的也可以是动态的。
                    固定式是不可能的，不予考虑。
                    维持动态页持有权的策略可以分为两类：集中式和分布式，分布式管理也可以根据持有数据的分布进一步分为固定的和动态的。
         最好的是两种策略组合使用，可以考虑的组合是集中式管理配上页失效，固定分布式管理配上页失效，动态分布式管理配上页失效。
                    
         页表，锁和失效：
            解决内存一致性的算法是通过用页错误处理，错误服务和使用的数据结构。数据结构至少有以下关于每个页的信息：访问权限，副本集，锁。也就是页表。
            页表的锁域上有两种原语操作，lock，unlock。同步多个页错误请求。
            在内存一致性算法中使用的另一个原语是 invalidate
            至少有三种使页副本失效的方式：独立式，广播式，多播式。
            合理假设远程操作都需要两个消息：一个请求和一个回复。
            在这种假设下，对于N个处理器系统上m个副本：
                            独立失效请求：需要2m个消息{m个请求，m个回复}
                            广播失效请求：{发送m+1个消息，收到N+m-1个消息(N-1个消息是并行接受的)}
                            多播失效请求：{发送m+1个消息，收到2m个消息(m个消息是并行接受的)}
                            
                            当N较小时可以使用bit vector来表示副本集
                            当N较大时，可以使用：linked bit vector,neighbor bit vector,vaguely defined set.
        集中管理算法：
                包含一个数据结构和一些提供互斥访问这个数据结构操作的过程。
                在多缓存系统中内存一致性有类似的解法：
                    集中管理者只在一台机器上，维持一张叫做info的表，每一页在这张表里有一个记录，记录包含三个域：
                            owner域：最近有写访问权限的处理器
                            副本集合：所有持有此页的处理器列表，这可以不用广播就能执行页失效操作。
                            锁：同步对页的请求。
                    每个处理器自己都有一张叫做Ptable的表，包含两个域：访问域(access)和锁(lock)域
                    这张表保存本地处理器可以访问的页的信息。这个算法里页没有固定的持有者，只有集中管理者知道是谁持有哪一页。
                    页的持有者会给请求读这个页的处理器发送一个页副本。只要读副本存在，没有页失效操作就不能对其进行写操作。
                    页失效操作会给所有持有此页读副本的处理器发送失效消息。成功对页进行写入的处理器总是对页享有持有权。
                    无论读还是写操作完成后，处理器都会给管理者发送一个确认信息来暗示操作的完成。那么处理器就可以随时将页权限转让。
                    info表和Ptable表都有基于页的锁。此时的锁机制是休眠队列或者休眠链表的做法。
                    在管理者处理器上，一次读页错误需要两个消息：一个发给页持有者，一个从页持有者接收。
                    在非管理者处理器上，就需要四个消息：一个发给管理者，一个发给页持有者，一个从页持有者接收，一个确认信息
                    一次写页错误除了需要页失效操作以外，其他都和读错误一样。
                    
                    因为集中式管理者扮演的是帮助其他处理器对页进行定位的角色，如果当处理器数量过多而且页错误也很多的话，在管理者处理器上就会
                    出现traffic瓶颈。当非管理者处理器有一个页错误，它会给管理员发送一个消息并从管理员处获得一个回复，那么算法就有一下属性：
                        集中式管理算法中定位一个页最差情况下需要两条消息。
                        但是还需要给管理者发送确认信息。
       改进式集中管理算法：(消除同步消息)
               与先前不同的是，把页持有权的同步移到独立持有页的处理器上，因此消除了对管理者的确认消息。
               每个处理器上的锁机制不仅解决多个本地请求，还解决多个远程请求。管理者仍然有定位页的功能，但是不再同步请求了。(？？？)
               (由每个处理器负责管理自己的页同步请求）。
