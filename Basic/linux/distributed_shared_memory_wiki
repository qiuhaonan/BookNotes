分布式共享内存是一种内存结构形式，在这个结构中，内存在物理上是分离的但是能够被当作逻辑上是一整块来进行访问。
共享的意思不是一个集中在一起的内存而是意味着地址空间是共享的，也就是说在两个处理器上相同的物理地址指的是内存中的同一个位置。
DGAS，分布式全局地址空间，是许多软硬件实现的术语，在这个空间下，集群中每个结点都能访问除了每个节点非共享私有内存以外的共享内存。
一个分布式内存系统有多个独立的处理结点和本地内存模块构成，他们通过一般的互联网络连接起来。
软件分布式共享内存系统可以在一个操作系统中或者在编程库中实现，而且可以被看作是当前虚拟内存架构的一种扩展。
当在操作系统中实现时，这个DSM对开发者是透明的，这意味着底层的分布式内存对用户是完全隐藏的。
相反，软件DSM系统在编程库或语言中实现时，就不是透明的了，开发者不得不针对具体情况进行编程。
然而，这些系统提供了一种更加方便地实现DSM的方法。
分布式共享内存系统在一个物理分布式内存系统实现了共享内存模型。


有三种方法可以实现软件分布式共享内存：
      1.基于内存页的方法：使用系统虚拟内存
            基于页的方法把共享内存组织成固定大小的内存页（有缺页风险）
      2.共享变量的方法：使用一些程序访问共享变量
      3.基于对象的方法：通过面向对象的方法来完美的访问共享数据
            基于对象的方法将共享内存区组织成一个抽象空间来存储可变大小的共享对象
            另一种常见的实现是使用一个元组空间，每个单元就是一个元组
                  所谓元组空间：
                        元组空间是分布式计算或并行计算里的一种联想存储范式的实现，它提供可以被并行访问的元组仓库。
                        举个典型的例子，假设有一组处理器产生数据片，而另一组处理器使用这些数据。生产者把数据以元组的形式放进
                        空间里，而消费者从空间里提取符合特定模式的数据，这也称为黑板隐喻(blackboard metaphor)。元组空间也可以被
                        看作是分布式共享内存的一种形式。
                        延伸：对象空间：对象空间是开发分布式计算应用的一种范式，存在逻辑实体是它的特征，称作对象空间.分布式应用的所有
                        参与者共享一个对象空间，一种服务的供应者将服务封装成一个对象，然后放进对象空间里，然后服务的客户访问这个对象
                        空间，找到提供他所需要的服务的对象，然后使用此对象来服务它的请求。【1980s】
            共享内存体系可能涉及到将内存分成一些共享的部分分布在结点和主存之间，或者把所有的内存都分布在结点间。
            按照一致性模型选择一个一致性协议来维持内存一致性。
消息传递 VS DSM：
      消息传递                          DSM
      变量需要编组                        变量直接共享
      通信耗费很明显                       通信耗费是隐式的
      拥有私有地址空间，进程受保护          通过修改数据能导致进程出错
      进程应该同时执行                     执行进程的生命周期也许是无覆盖的
      
DSM的优点：
      系统可扩展
      隐藏消息传递(非应用编程人员显式调用消息传递API)
      不用复制或者将数据发送给进程就能处理大型复杂数据库
      DSM通常比使用多处理器系统更cheaper
      没有内存访问瓶颈，因为没有单总线
      DSM提供大型虚拟内存空间
      因为使用通用DSM编程接口，所以DMS程序可以移植
      发送接收原语对程序猿不可见
      DSM可能会加速数据访问来提升性能
      
实现中的问题DSM software：
      数据被复制或者缓存起来（因为从共享内存取过来的数据必须被存起来）
      降低延迟
      并发访问的语义必须明确指定
      DSM是应该被内存管理软件，还是操作系统，还是语言运行时系统控制？
      怎样定位远程数据
      粒度问题：单个操作应该传输多少数据

DSM的缺点：
      会导致性能损失
      应该提供对共享数据同时访问的保护，比如：锁
      非常规问题的性能可能会很差
      
实现DSM的方式：
      硬件：缓存一致性电路和网络接口
      软件

一致性模型：
      内存系统基于系统中的叫做系统的一致性模型的特定规则进行运转
      
内存一致性：
      内存一致性是DSM系统中最重要因素之一，它能确保系统正确的执行和内存操作。
      内存一致性定义哪些交叉操作是允许的。传统上，读操作返回最近写操作写的值，但这个值会因为副本和并发访问而产生模糊性。
      
严格一致性：
      在严格一致性上，每个操作都被贴上一个全局现实时间。
      规则：
            每次读会得到最近写的值
            在一个CPU上的所有操作都是按照他们的时间标签顺序来执行的
      多处理器通过向所有处理器广播写操作来维持缓存一致性，然后要么是更新局部缓存或者使局部缓存失效。
      因为软件分布式共享内存不能实现维持严格一致性的原子广播，其他的一致性模型需要这个。
      
顺序一致性：
      顺序一致性是指：如果处理器的所有操作都是顺序执行的，那么任何执行的结果都是相同的，每个处理器的操作以本地程序的顺序出现在这个序列中。
      可能来自不同处理器的操作会交叉在一起，但处理器应该满足同样的交叉。
      顺序一致性是比严格一致性稍微弱的模型。它们之间最重要的区别就是顺序一致性不是实时的。
      规则：
            存在一个总的操作顺序，以至于：
                  每台机器自己的操作按序出现
                  所有的机器按照总顺序看见结果。例如：读操作会读到最近写的数据。换句话说，所有进程的指令是以一定顺序交叉的。
      对于独立进程，顺序一致性没什么问题。
      对于临界区，就有可能产生竞争条件。希望强制以一定顺序执行的用户可以使用同步机制，在共享内存的处理器中是同样的方式。
      
缓慢内存一致性：
      慢内存是最弱的一致性模型中的一员，这些模型仍被进程间通信使用。
      在这个一致性模型中，所有的处理器必须就观察到的某个处理器对每个位置的写操作顺序达成一致，就是说他们看到的顺序是一样的。
      不仅如此，本地写应该是立刻可见的。
      
DSM中的复制：
      复制共享数据通常减少网络流量，提高并行性，减少页面错误，并且比非复制实现更有效。
      主要问题：当出现多个副本时维持副本间的一致性问题
      
结构化DSM中的一致性：
      基于对象或者结构化的DSM也许使用更加有效的一致性，因为它更容易指明哪些会被共享。
      用户可以指定程序中哪一点数据是一致性的。
      他们仅仅共享指定的对象或者变量。
      如果访问共享数据只发生在临界区内，此时一个进程进入临界区，DSM就只需要确保变量是一致性的。
      
两种一致性模型：
      发布一致性：当进程处于临界区时，变量的新值会传播给所有的站点
      进入一致性：当进程进入临界区时，它会自动更新共享变量的值
      基于视图的一致性：这是进入一致性的变体，区别在于临界区的共享变量会自动被系统检测到。
      
                  
