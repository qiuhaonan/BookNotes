现代操作系统包括了两种对用户空间的基础的虚拟抽象：虚拟内存和虚拟处理器
它们使得进程“感觉”自己独占机器资源。
    虚拟内存：为每个进程提供独立的内存地址空间，该内存地址连续映射到物理RAM或磁盘存储(分页实现)。
             每个进程“感觉”所有的内存都是自己独占的，虚拟处理器使进程“感觉”只有自己在运行。
             虚拟内存与进程相关，与线程无关，因此，每个进程都有独立的内存空间，而进程中的所有线程共享这份内存空间。

相反，虚拟处理器与线程相关，与进程无关。
    虚拟处理器：使每个线程也“感觉”自己独占一个处理器。但线程不会“感觉”自己独占一块内存，因为所有的线程共享全部内存地址空间。
              每个线程都是可独立调度的实体，支持单个进程每次“处理”多个操作。

多线程机制好处：
      编程抽象，并发性，提高响应能力，I/O阻塞，上下文切换，内存保存
      
上下文切换中：
      进程切换涉及把一个虚拟地址空间切换到另一个虚拟地址空间，eg:在x86系统上，TLB(把虚拟内存地址映射到物理内存地址)
      当切换虚拟地址空间时，必须都清空；对线程而言，则不会切换虚拟地址空间。
      
线程模型：
      内核级线程模型：1:1线程模型，在内核为线程提供了本地支持，每个内核线程直接转换成用户空间的线程，是系统线程模型的核心。
                    在linux内核中只是简单地将线程实现为能够共享资源的进程，线程库通过系统调用clone()创建一个新的线程，
                    返回的“进程”直接作为用户空间的线程，也就是说在linux上，用户调用线程和内核调用线程基本一致。
      用户级线程模型：N:1线程模型，一个包含N个线程的进程只会映射到一个内核进程，优点是上下文切换几乎是零成本的，因为应用
                    本身可以决定何时运行哪个线程，不需要内核操作，缺点在于由于支持线程的内核实体只有一个，该模型无法利用
                    多处理器，因此无法提供真正的并行性。但是在现代操作系统中，这个缺点很严重，尤其在linux上，因为减少上下文
                    切换代价带来的好处微乎其微，因为linux支持非常低成本的上下文切换。
                    
线程模式：
      是应用程序的逻辑处理和I/O的模式，两个核心的编程模式是：每个连接对应一个线程；事件驱动
      每个连接对应一个线程：
                    每个工作单元被分配给一个线程，而该线程在该工作单元执行期间，不会被分配给其他工作单元(分解应用的工作)。
                    释义：“运行直到结束”
                    采用阻塞式I/O，实际上任何IO都是允许的，因为连接“持有”该线程。
                    阻塞线程只会中止引起阻塞的连接。在这种情况下，此模式使用内核处理工作调度以及I/O管理。
                    注意，在此模式下本身不需要线程，若换成进程，就相当于描述老的unix服务器。
                    
      事件驱动：
                    对于计算能力，当前硬件可以同时处理多个请求，在“每个连接对应一个线程”模式中，就需要很多线程，
                    线程本身的成本是固定的，主要需要内核和用户空间栈。
                    这些固有成本带来了可扩展性上限，对每一个进程中的线程数有上限，尤其是32位系统。
                    实际上：使用的线程数如果超出系统的处理器个数，并不会给并发带来任何好处。
                    在“每个连接对应一个线程”模式中大部分工作负荷是在等待，我们把这些等待操作从线程中剥离出来。
                    转而通过发送异步I/O请求和使用I/O多路复用来管理服务器中的控制流。在这种模式下，请求处理转换成一系列异步I/O请求
                    及其关联的回调函数。这些回调函数可能会通过I/O多路复用方式来等待，完成该操作的进程称为“事件循环“。当返回I/O请求时，
                    事件循环会向等待的线程发送回调。
    在设计多线程的系统软件时，建议首先考虑事件驱动模式：异步I/O，回调，事件循环，一个很小的线程池，每个处理器只有一个线程。
    
    锁住数据而不是代码。
    
    Pthread API
    Pthread函数可以划分成两个大的分组：
           线程管理：
                  完成创建、销毁、连接和detach线程的函数。
           同步：
                  管理线程的同步的函数，包括互斥、条件变量和障碍。
                  
    #include<pthread.h>
    int pthread_create(pthread_t *thread,const pthread_attr_t *attr,void *(*start_routine)(void *),void *arg);
    void pthread_exit(void *retrival);
    int pthread_cancel(pthread_t thread);
    int pthread_join(pthread_t thread,void **retrival);
    int pthread_detach(pthread_t thread);
