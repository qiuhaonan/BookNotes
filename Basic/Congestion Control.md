# Congestion Control
TCP的本质策略是向网络上无预留的注入数据包，然后根据观测到发生的事件来做出反应。广泛的来看，TCP拥塞控制的核心思想是让每个源来确定网络上有多少可用资源，那么它们就知道它们可以安全的传输多少个数据包。

当然，确定可用资源容量不是一件容易的事情。网络上的连接产生然后消失，可用带宽也随时间变化，意味着任意一个源必须能调整它能发送数据包的数量。

## 1. 加法增加/乘法减少(Tahoe)
**TCP**为每一个连接维持一个新的状态变量，叫做拥塞窗口，用来限制每个源在给定时间内能够向网络中注入数据包的数量。拥塞控制中的拥塞窗口对应的是流量控制中的建议窗口。因此，现在最大未确认的字节数是拥塞窗口和建议窗口两者之间的最小值。

- 问题在于，**TCP**怎么能学习到一个合适的拥塞窗口大小。与建议窗口不同，建议窗口是接收方主动告诉发送方这个合适的窗口大小。
    - 解决方法是让发送方根据可感知的网络拥塞程度来调整拥塞窗口大小。

- 这中间的核心问题是发送方怎么确定网络是拥塞的然后减小窗口。
    - 解决方法是基于以下观察得到的
        - 数据包没有交付成功，并且出现超时，主要原因就是数据包由于拥塞在网络上被丢弃了
        - 并且因为传输的错误导致的丢包非常罕见

如果只是减小拥塞窗口大小，那么这个拥塞控制策略就显得太保守。我们也需要能够增加拥塞窗口来利用网络上最近可用的容量。

- 为什么发送方愿意以比增加拥塞窗口较快的速度减小拥塞窗口
    - 直观的原因是拥有一个太大的拥塞窗口导致的后果比拥有小的拥塞窗口要严重

## 2. 慢启动(Tahoe)
加法增加机制描述了当发送方使用的容量快要接近网络可用容量时的方法，但是当发送方从新开始使用网络容量时，这种方法需要很长时间才能将一个连接的网络容量提升到网路可用容量。因此，**TCP**提出了另一种机制，叫做慢启动，使用指数方式来增加拥塞窗口大小，来解决这个问题
- 为什么要叫慢启动呢？它明明很快，比加法增加要快很多
    - 慢启动的比较对象不是加法增加，在**TCP**早期机制中，发送方在一开始使用网络时是以建议窗口允许的最大数据包数量向网络中注入数据包，但是网络中的路由器可能由于可用缓存空间导致无法接收大量的突发数据包，因此，慢启动是为了防止这种突发数据包产生
- 慢启动和加法增加的区别是什么
    - 加法增加是每次收到一个**ack**之后增加一个**MSS**的一部分，结果是当整个拥塞窗口的数据包都被**ack**之后，拥塞窗口会加一
    - 慢启动是每次收到一个**ack**之后增加一个**MSS**，结果是每个**RTT**内，拥塞窗口会翻倍增长
- 慢启动使用的场景有哪些？
    - 在连接刚开始的时候，发送方不知道此时能够发送多少个数据包到网络中去
    - 在连接的拥塞窗口可用大小为0且发生了超时，此时无法发送任何数据，且也不会有**ack**到达，那么发送方会使用慢启动来重新向网络中注入数据流，而不是把整个窗口的大小一下全注入网络中，且此时的发送方已经知道网络中的可用容量了，称作目标窗口，等于之前的拥塞窗口折半的值，新的拥塞窗口重置为1
- 慢启动会有哪些问题？
    - 在指数增长阶段，网络可能会丢掉发送方拥塞窗口一半的数据包
    - 这个问题会随着时延带宽积的增长而变得更严重

## 3. 快重传(Tahoe)和快恢复(Reno)
当一个连接已经耗尽了拥塞窗口但却一直在等待超时时，粗粒度的超时机制导致过长的等待时间。快重传是一种启发式方法：有时触发重传一个丢掉的数据包要比常规的超时机制快。快重传只是作为超时机制的增强。

- 快重传的思想是什么
    - 接收方在受到数据包时，都会给一个**ack**，即便该序列号已经被**ack**过
    - 那么当一个乱序的数据包到达时，接收方重传对上一个**ack**的序列号
    - 当发送方受到重复的序列号时，就会感知到发生了丢包事件
    - 因为也有可能是数据包在网络中经历了延迟，因此发送方应该等待看到一定数量的重复序列号时才能以较大概率确定是丢包了
- 为什么快重传是三次重复**ack**
    - 两次重复**ack**肯定是乱序造成的；丢包肯定会造成三次重复**ack**
- 为什么快重传无法替代超时机制
    - 因为对于小窗口来说，无法产生触发快重传所需要的重复**ack**数量

现在，每次收到快重传信号时，就会使得拥塞窗口重置，然后使用慢启动来恢复，效率不够高，为了消除发生在快重传和加法增加之间的慢启动，快恢复机制被引入了进来
- 快恢复的做法和思想是什么
    - 快恢复在每次收到快重传信号时，将拥塞窗口减半，目标窗口也就是门限值设为当前的拥塞窗口，然后把拥塞窗口设为门限值加上3个**MSS**大小，重传重复**ack**的数据包，如果再收到之前重复**ack**，就把拥塞窗口加1，如果受到了新的**ack**，那么就把拥塞窗口设为门限值，接着进入加法增加阶段
    - 由于慢启动的目标窗口是发生拥塞时拥塞窗口的一半，也就是说发送方的拥塞窗口最终仍然会增长到之前拥塞窗口的一半，那么指数逼近的时延要高于全速逼近的时延，而快恢复的思想是快重传发生时，说明网络也并不糟糕，那么就不必要恢复到慢启动，可以直接进入加法增加阶段

## 4. New Reno
快重传依赖于3个重复的**ack**，但是无法区分是丢了一个数据包还是多个数据包，当丢了多个数据包时，只有第一个数据包会被快重传解决，后面丢的数据包会触发超时事件，不断把拥塞窗口减半，进入噩梦模式，不会触发快恢复算法了，因此，需要一种新的算法来解决该问题。一般来说**TCP**的实现中有**sack**的话，可以缓解这个问题，但是并非所有的**TCP**协议都支持**sack**，因此，**New Reno**要在没有**sack**的支持下改进快恢复算法来解决该问题。

- **New Reno**是怎么做的呢？
    - 当发送方受到了3个重复**ack**之后，进入快重传模式，开始重发指示的数据包，如果只有这一个数据包丢失了，那么重传这个数据包回来的**ack**会把整个已经被发送方传输出去的数据包**ack**回来，否则，就说明有多个数据包丢失了，这个**ack**叫做**partial ack**
    - 一旦发送方发现了有**partial ack**出现时，就可以推断出有多个数据包丢失了，于是就继续重传滑动窗口中没有被**ack**的第一个数据包，直到再也没有**partial ack**出现，才真正结束快恢复过程

## 5. Vegas
这个算法1994年被提出，它主要对**TCP Reno** 做了些修改。这个算法通过对**RTT**的非常重的监控来计算一个基准**RTT**。然后通过这个基准**RTT**来估计当前的网络实际带宽，如果实际带宽比我们的期望的带宽要小或是要多的活，那么就开始线性地减少或增加**cwnd**的大小。如果这个计算出来的**RTT**大于了**Timeout**后，那么，不等**ack**超时就直接重传。（**Vegas** 的核心思想是用RTT的值来影响拥塞窗口，而不是通过丢包）

## 6. BIC
2004年，产内出**BIC**算法。现在你还可以查得到相关的新闻《Google：美科学家研发BIC-TCP协议 速度是DSL六千倍》 **BIC**全称**Binary Increase Congestion control**，在**Linux 2.6.8**中是默认拥塞控制算法。**BIC**的发明者发这么多的拥塞控制算法都在努力找一个合适的**cwnd – Congestion Window**，而且**BIC-TCP**的提出者们看穿了事情的本质，其实这就是一个搜索的过程，所以**BIC**这个算法主要用的是**Binary Search**——二分查找来干这个事。

## 7. 参考资料
- [快重传3次ack](https://www.zhihu.com/question/21789252)
- [内核源码](https://elixir.bootlin.com/linux/v2.6.26.8/source/net)
- 计算机网络系统方法-拥塞控制
