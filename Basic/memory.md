# Memory
- 进程地址空间
  - text段：可执行文件镜像
  - Data段：初始化数据段，全局变量，静态局部变量
  - BSS段：未初始化数据段，全局变量
  - 堆：动态分配内存段
  - 内存映射段：共享库加载段，内存映射
  - 栈：程序临时创建的局部变量，但不包含static声明的变量
- 内存分配回收
  - new
    - 调用operator new函数分配内存
    - 调用构造函数
    - 返回对象指针
  - delete
    - 调用析构函数
    - 调用operator delete函数释放内存
  - new/delete与malloc/free的区别
    - 前者是操作符，后者是函数
    - new不需要指定内存块大小，malloc需要显式地指出所需内存大小
    - new/delete会调用构造函数和析构函数，malloc/free不会
    - new返回对象类型的指针，无需类型转换，而malloc返回的是void * , 需要强制类型转换
    - malloc效率更高
    - new/delete可以被重载，但是malloc/free不能被重载
- 内存错误
  - 内存分配未成功，却使用了它
  - 内存分配成功，但未初始化就使用
  - 内存分配和初始化成功，但访问越界
  - 忘记释放内存
  - 释放内存之后仍然访问它
  - 重复释放内存
- 缓冲区溢出
  - 缓冲区是一块可读写的连续的计算机内存区域，高级语言定义的变量，数组，结构体等在运行时间可以说都是保存在缓冲区内的，除了代码和受系统保护的数据区域，其他的内存区都可以作为缓冲区
  - c/c++中通常使用字符数组和malloc/new内存分配函数来分配缓冲区
  - 溢出原理
    - 在程序将数据读入或复制到缓冲区中时，数据长度超过了缓冲区长度，由于栈是低地址方向增长的，因此局部数据buffer的指针在缓冲区的下方，因此，数据长度超过缓冲区长度时会覆盖掉原本的其他栈帧数据
      - 覆盖其他局部变量
      - 覆盖ebp值，修改了函数执行结束后要恢复的栈指针
      - 覆盖了返回地址，使程序代码执行意外的流程
      - 覆盖参数变量，改变函数执行结果和流程
      - 覆盖上级函数的栈帧，影响上级函数执行
- 函数栈帧
  - 栈的主要功能是实现函数的调用，每次函数调用时，系统会把函数的返回地址，一些关键的寄存器值保存在栈内，函数的实际参数和局部变量(包括数据，结构体，对象等)也会保存在栈内，每次函数调用都会有个独立的栈帧
- 内存泄露
  - 程序未能释放已经不再使用的内存，一般指堆中的内存泄露
    - 无主内存：申请完内存后丢失指针
    - 异常分支导致资源未释放：异常处理代码中，系统资源未释放
    - 类的析构函数为非虚函数：派生类对象未能正确释放自己的资源，而是释放了基类的资源
  - 检查
    - mtrace
    - valgrind
